"""Full integration testing, from schema declaration to on-disk file verification."""

from __future__ import annotations

from typing import TYPE_CHECKING, cast

import numpy as np
import pytest
import yaozarrs
from yaozarrs import v05

from ome_writers import (
    AcquisitionSettings,
    ArraySettings,
    Dimension,
    PositionDimension,
    create_stream,
)

if TYPE_CHECKING:
    from pathlib import Path

    import tensorstore

# NOTES:
# - All root_paths will be replaced with temporary directories during testing.
D = Dimension  # alias, for brevity
CASES = [
    AcquisitionSettings(
        root_path="tmp",
        array_settings=ArraySettings(
            dimensions=[
                D(name="t", count=2, type="time"),
                D(name="c", count=3, type="channel"),
                D(name="z", count=4, type="space", scale=5),
                D(name="y", count=128, chunk_size=64, type="space", scale=0.1),
                D(name="x", count=128, chunk_size=64, type="space", scale=0.1),
            ],
            dtype="uint16",
        ),
    ),
    # transpose z and c ...
    # because we always write out valid OME-Zarr by default (i.e. TCZYX as of v0.5)
    # this exercises non-standard dimension orders
    # validation is ensured by yaozarrs.validate_zarr_store()
    AcquisitionSettings(
        root_path="tmp",
        array_settings=ArraySettings(
            dimensions=[
                D(name="t", count=2, type="time"),
                D(name="z", count=4, type="space", scale=5),
                D(name="c", count=3, type="channel"),
                D(name="y", count=128, chunk_size=64, type="space", scale=0.1),
                D(name="x", count=128, chunk_size=64, type="space", scale=0.1),
            ],
            dtype="uint16",
        ),
    ),
    # Multi-position case
    AcquisitionSettings(
        root_path="tmp",
        array_settings=ArraySettings(
            dimensions=[
                PositionDimension(positions=["Pos0", "Pos1"]),
                D(name="MyZ", count=4, type="space"),
                D(name="MyY", count=128, chunk_size=64, type="space", scale=0.1),
                D(name="MyX", count=128, chunk_size=64, type="space", scale=0.1),
            ],
            dtype="uint16",
        ),
    ),
]


@pytest.mark.parametrize("case", CASES)
@pytest.mark.parametrize("backend", ["zarr", "tensorstore"])
def test_cases_as_zarr(case: AcquisitionSettings, backend: str, tmp_path: Path) -> None:
    case.root_path = root = tmp_path / "output.zarr"
    case.backend = backend
    dims = case.array_settings.dimensions
    dtype = case.array_settings.dtype
    # currently, we enforce that the last 2 dimensions are the frame dimensions
    frame_shape = cast("tuple[int, ...]", tuple(d.count for d in dims[-2:]))

    # -------------- Write out all frames --------------

    with create_stream(case) as stream:
        router = stream._router
        num_positions = len(router.positions)
        stored_array_dims = router.array_storage_dimensions
        for f in range(router.num_frames):
            frame_data = np.full(frame_shape, f, dtype=dtype)
            stream.append(frame_data)

    # -------------- Validate the result --------------
    group = yaozarrs.validate_zarr_store(root)
    ome_meta = group.ome_metadata()

    # Assert group type (single image, multi-position, plate)
    # and collect image paths for further validation
    image_paths: list[Path] = []
    # Plate
    if case.plate is not None:
        assert isinstance(ome_meta, v05.Plate)
    # Single image
    elif num_positions == 1:
        assert isinstance(ome_meta, v05.Image)
        image_paths = [root]
    # Multi-position
    else:
        assert isinstance(ome_meta, v05.Bf2Raw)
        ome_group = yaozarrs.validate_ome_uri(root / "OME")
        ome_meta = ome_group.attributes.ome
        assert isinstance(ome_meta, v05.Series)
        image_paths = [(root / path) for path in ome_meta.series]

    assert len(image_paths) == num_positions
    _validate_images(stored_array_dims, image_paths, dtype)


def _validate_images(
    storage_dims: list[D], image_paths: list[Path], dtype: str
) -> None:
    """Validate all images (multiscales groups) generated by a test."""
    for image_path in image_paths:
        group = yaozarrs.open_group(image_path)
        image = group.ome_metadata()
        assert isinstance(image, v05.Image), (
            f"Expected Image group at {image_path}, got {type(image)}"
        )
        try:
            import tensorstore
        except ImportError:
            print("tensorstore not installed; skipping tensorstore-specific checks")
            return

        array0 = group["0"].to_tensorstore()  # type: ignore[possibly-unbound-attribute]
        assert isinstance(array0, tensorstore.TensorStore)
        assert array0.dtype == np.dtype(dtype)
        assert array0.shape == tuple(d.count for d in storage_dims)
        assert [d.label for d in array0.domain] == [d.name for d in storage_dims]  # type: ignore

        # validate chunking
        _validate_chunks(array0, storage_dims)

        # validate sharding
        # TODO


def _validate_chunks(array: tensorstore.TensorStore, storage_dims: list[D]) -> None:
    # TODO: this expectation should be codified somewhere central, maybe in the router
    expected_chunk_shape = tuple(d.chunk_size or 1 for d in storage_dims)
    actual_chunk_shape = array.chunk_layout.read_chunk.shape
    assert actual_chunk_shape == expected_chunk_shape, (
        f"expected {expected_chunk_shape}, got {actual_chunk_shape}"
    )
